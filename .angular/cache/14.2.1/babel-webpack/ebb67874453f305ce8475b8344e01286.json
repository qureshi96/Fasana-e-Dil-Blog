{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar tslib = require('tslib');\n\nvar util = require('@firebase/util');\n/**\r\n * Component for service name T, e.g. `auth`, `auth-internal`\r\n */\n\n\nvar Component =\n/** @class */\nfunction () {\n  /**\r\n   *\r\n   * @param name The public service name, e.g. app, auth, firestore, database\r\n   * @param instanceFactory Service factory responsible for creating the public interface\r\n   * @param type whether the service provided by the component is public or private\r\n   */\n  function Component(name, instanceFactory, type) {\n    this.name = name;\n    this.instanceFactory = instanceFactory;\n    this.type = type;\n    this.multipleInstances = false;\n    /**\r\n     * Properties to be added to the service namespace\r\n     */\n\n    this.serviceProps = {};\n    this.instantiationMode = \"LAZY\"\n    /* LAZY */\n    ;\n  }\n\n  Component.prototype.setInstantiationMode = function (mode) {\n    this.instantiationMode = mode;\n    return this;\n  };\n\n  Component.prototype.setMultipleInstances = function (multipleInstances) {\n    this.multipleInstances = multipleInstances;\n    return this;\n  };\n\n  Component.prototype.setServiceProps = function (props) {\n    this.serviceProps = props;\n    return this;\n  };\n\n  return Component;\n}();\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nvar DEFAULT_ENTRY_NAME = '[DEFAULT]';\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\r\n * NameServiceMapping[T] is an alias for the type of the instance\r\n */\n\nvar Provider =\n/** @class */\nfunction () {\n  function Provider(name, container) {\n    this.name = name;\n    this.container = container;\n    this.component = null;\n    this.instances = new Map();\n    this.instancesDeferred = new Map();\n  }\n  /**\r\n   * @param identifier A provider can provide mulitple instances of a service\r\n   * if this.component.multipleInstances is true.\r\n   */\n\n\n  Provider.prototype.get = function (identifier) {\n    if (identifier === void 0) {\n      identifier = DEFAULT_ENTRY_NAME;\n    } // if multipleInstances is not supported, use the default name\n\n\n    var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n\n    if (!this.instancesDeferred.has(normalizedIdentifier)) {\n      var deferred = new util.Deferred();\n      this.instancesDeferred.set(normalizedIdentifier, deferred); // If the service instance is available, resolve the promise with it immediately\n\n      try {\n        var instance = this.getOrInitializeService(normalizedIdentifier);\n\n        if (instance) {\n          deferred.resolve(instance);\n        }\n      } catch (e) {// when the instance factory throws an exception during get(), it should not cause\n        // a fatal error. We just return the unresolved promise in this case.\n      }\n    }\n\n    return this.instancesDeferred.get(normalizedIdentifier).promise;\n  };\n\n  Provider.prototype.getImmediate = function (options) {\n    var _a = tslib.__assign({\n      identifier: DEFAULT_ENTRY_NAME,\n      optional: false\n    }, options),\n        identifier = _a.identifier,\n        optional = _a.optional; // if multipleInstances is not supported, use the default name\n\n\n    var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n\n    try {\n      var instance = this.getOrInitializeService(normalizedIdentifier);\n\n      if (!instance) {\n        if (optional) {\n          return null;\n        }\n\n        throw Error(\"Service \" + this.name + \" is not available\");\n      }\n\n      return instance;\n    } catch (e) {\n      if (optional) {\n        return null;\n      } else {\n        throw e;\n      }\n    }\n  };\n\n  Provider.prototype.getComponent = function () {\n    return this.component;\n  };\n\n  Provider.prototype.setComponent = function (component) {\n    var e_1, _a;\n\n    if (component.name !== this.name) {\n      throw Error(\"Mismatching Component \" + component.name + \" for Provider \" + this.name + \".\");\n    }\n\n    if (this.component) {\n      throw Error(\"Component for \" + this.name + \" has already been provided\");\n    }\n\n    this.component = component; // if the service is eager, initialize the default instance\n\n    if (isComponentEager(component)) {\n      try {\n        this.getOrInitializeService(DEFAULT_ENTRY_NAME);\n      } catch (e) {// when the instance factory for an eager Component throws an exception during the eager\n        // initialization, it should not cause a fatal error.\n        // TODO: Investigate if we need to make it configurable, because some component may want to cause\n        // a fatal error in this case?\n      }\n    }\n\n    try {\n      // Create service instances for the pending promises and resolve them\n      // NOTE: if this.multipleInstances is false, only the default instance will be created\n      // and all promises with resolve with it regardless of the identifier.\n      for (var _b = tslib.__values(this.instancesDeferred.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var _d = tslib.__read(_c.value, 2),\n            instanceIdentifier = _d[0],\n            instanceDeferred = _d[1];\n\n        var normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n\n        try {\n          // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\n          var instance = this.getOrInitializeService(normalizedIdentifier);\n          instanceDeferred.resolve(instance);\n        } catch (e) {// when the instance factory throws an exception, it should not cause\n          // a fatal error. We just leave the promise unresolved.\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n\n  Provider.prototype.clearInstance = function (identifier) {\n    if (identifier === void 0) {\n      identifier = DEFAULT_ENTRY_NAME;\n    }\n\n    this.instancesDeferred.delete(identifier);\n    this.instances.delete(identifier);\n  }; // app.delete() will call this method on every provider to delete the services\n  // TODO: should we mark the provider as deleted?\n\n\n  Provider.prototype.delete = function () {\n    return tslib.__awaiter(this, void 0, void 0, function () {\n      var services;\n      return tslib.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            services = Array.from(this.instances.values());\n            return [4\n            /*yield*/\n            , Promise.all(tslib.__spread(services.filter(function (service) {\n              return 'INTERNAL' in service;\n            }) // legacy services\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            .map(function (service) {\n              return service.INTERNAL.delete();\n            }), services.filter(function (service) {\n              return '_delete' in service;\n            }) // modularized services\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            .map(function (service) {\n              return service._delete();\n            })))];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Provider.prototype.isComponentSet = function () {\n    return this.component != null;\n  };\n\n  Provider.prototype.getOrInitializeService = function (identifier) {\n    var instance = this.instances.get(identifier);\n\n    if (!instance && this.component) {\n      instance = this.component.instanceFactory(this.container, normalizeIdentifierForFactory(identifier));\n      this.instances.set(identifier, instance);\n    }\n\n    return instance || null;\n  };\n\n  Provider.prototype.normalizeInstanceIdentifier = function (identifier) {\n    if (this.component) {\n      return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\n    } else {\n      return identifier; // assume multiple instances are supported before the component is provided.\n    }\n  };\n\n  return Provider;\n}(); // undefined should be passed to the service factory for the default instance\n\n\nfunction normalizeIdentifierForFactory(identifier) {\n  return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\n}\n\nfunction isComponentEager(component) {\n  return component.instantiationMode === \"EAGER\"\n  /* EAGER */\n  ;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\r\n */\n\n\nvar ComponentContainer =\n/** @class */\nfunction () {\n  function ComponentContainer(name) {\n    this.name = name;\n    this.providers = new Map();\n  }\n  /**\r\n   *\r\n   * @param component Component being added\r\n   * @param overwrite When a component with the same name has already been registered,\r\n   * if overwrite is true: overwrite the existing component with the new component and create a new\r\n   * provider with the new component. It can be useful in tests where you want to use different mocks\r\n   * for different tests.\r\n   * if overwrite is false: throw an exception\r\n   */\n\n\n  ComponentContainer.prototype.addComponent = function (component) {\n    var provider = this.getProvider(component.name);\n\n    if (provider.isComponentSet()) {\n      throw new Error(\"Component \" + component.name + \" has already been registered with \" + this.name);\n    }\n\n    provider.setComponent(component);\n  };\n\n  ComponentContainer.prototype.addOrOverwriteComponent = function (component) {\n    var provider = this.getProvider(component.name);\n\n    if (provider.isComponentSet()) {\n      // delete the existing provider from the container, so we can register the new component\n      this.providers.delete(component.name);\n    }\n\n    this.addComponent(component);\n  };\n  /**\r\n   * getProvider provides a type safe interface where it can only be called with a field name\r\n   * present in NameServiceMapping interface.\r\n   *\r\n   * Firebase SDKs providing services should extend NameServiceMapping interface to register\r\n   * themselves.\r\n   */\n\n\n  ComponentContainer.prototype.getProvider = function (name) {\n    if (this.providers.has(name)) {\n      return this.providers.get(name);\n    } // create a Provider for a service that hasn't registered with Firebase\n\n\n    var provider = new Provider(name, this);\n    this.providers.set(name, provider);\n    return provider;\n  };\n\n  ComponentContainer.prototype.getProviders = function () {\n    return Array.from(this.providers.values());\n  };\n\n  return ComponentContainer;\n}();\n\nexports.Component = Component;\nexports.ComponentContainer = ComponentContainer;\nexports.Provider = Provider;","map":{"version":3,"names":["Object","defineProperty","exports","value","tslib","require","util","Component","name","instanceFactory","type","multipleInstances","serviceProps","instantiationMode","prototype","setInstantiationMode","mode","setMultipleInstances","setServiceProps","props","DEFAULT_ENTRY_NAME","Provider","container","component","instances","Map","instancesDeferred","get","identifier","normalizedIdentifier","normalizeInstanceIdentifier","has","deferred","Deferred","set","instance","getOrInitializeService","resolve","e","promise","getImmediate","options","_a","__assign","optional","Error","getComponent","setComponent","e_1","isComponentEager","_b","__values","entries","_c","next","done","_d","__read","instanceIdentifier","instanceDeferred","e_1_1","error","return","call","clearInstance","delete","__awaiter","services","__generator","label","Array","from","values","Promise","all","__spread","filter","service","map","INTERNAL","_delete","sent","isComponentSet","normalizeIdentifierForFactory","undefined","ComponentContainer","providers","addComponent","provider","getProvider","addOrOverwriteComponent","getProviders"],"sources":["/Users/usman/Documents/GitHub/Fasana-e-Dil-Blog/node_modules/@firebase/component/dist/index.cjs.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar tslib = require('tslib');\nvar util = require('@firebase/util');\n\n/**\r\n * Component for service name T, e.g. `auth`, `auth-internal`\r\n */\r\nvar Component = /** @class */ (function () {\r\n    /**\r\n     *\r\n     * @param name The public service name, e.g. app, auth, firestore, database\r\n     * @param instanceFactory Service factory responsible for creating the public interface\r\n     * @param type whether the service provided by the component is public or private\r\n     */\r\n    function Component(name, instanceFactory, type) {\r\n        this.name = name;\r\n        this.instanceFactory = instanceFactory;\r\n        this.type = type;\r\n        this.multipleInstances = false;\r\n        /**\r\n         * Properties to be added to the service namespace\r\n         */\r\n        this.serviceProps = {};\r\n        this.instantiationMode = \"LAZY\" /* LAZY */;\r\n    }\r\n    Component.prototype.setInstantiationMode = function (mode) {\r\n        this.instantiationMode = mode;\r\n        return this;\r\n    };\r\n    Component.prototype.setMultipleInstances = function (multipleInstances) {\r\n        this.multipleInstances = multipleInstances;\r\n        return this;\r\n    };\r\n    Component.prototype.setServiceProps = function (props) {\r\n        this.serviceProps = props;\r\n        return this;\r\n    };\r\n    return Component;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\r\n * NameServiceMapping[T] is an alias for the type of the instance\r\n */\r\nvar Provider = /** @class */ (function () {\r\n    function Provider(name, container) {\r\n        this.name = name;\r\n        this.container = container;\r\n        this.component = null;\r\n        this.instances = new Map();\r\n        this.instancesDeferred = new Map();\r\n    }\r\n    /**\r\n     * @param identifier A provider can provide mulitple instances of a service\r\n     * if this.component.multipleInstances is true.\r\n     */\r\n    Provider.prototype.get = function (identifier) {\r\n        if (identifier === void 0) { identifier = DEFAULT_ENTRY_NAME; }\r\n        // if multipleInstances is not supported, use the default name\r\n        var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\r\n        if (!this.instancesDeferred.has(normalizedIdentifier)) {\r\n            var deferred = new util.Deferred();\r\n            this.instancesDeferred.set(normalizedIdentifier, deferred);\r\n            // If the service instance is available, resolve the promise with it immediately\r\n            try {\r\n                var instance = this.getOrInitializeService(normalizedIdentifier);\r\n                if (instance) {\r\n                    deferred.resolve(instance);\r\n                }\r\n            }\r\n            catch (e) {\r\n                // when the instance factory throws an exception during get(), it should not cause\r\n                // a fatal error. We just return the unresolved promise in this case.\r\n            }\r\n        }\r\n        return this.instancesDeferred.get(normalizedIdentifier).promise;\r\n    };\r\n    Provider.prototype.getImmediate = function (options) {\r\n        var _a = tslib.__assign({ identifier: DEFAULT_ENTRY_NAME, optional: false }, options), identifier = _a.identifier, optional = _a.optional;\r\n        // if multipleInstances is not supported, use the default name\r\n        var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\r\n        try {\r\n            var instance = this.getOrInitializeService(normalizedIdentifier);\r\n            if (!instance) {\r\n                if (optional) {\r\n                    return null;\r\n                }\r\n                throw Error(\"Service \" + this.name + \" is not available\");\r\n            }\r\n            return instance;\r\n        }\r\n        catch (e) {\r\n            if (optional) {\r\n                return null;\r\n            }\r\n            else {\r\n                throw e;\r\n            }\r\n        }\r\n    };\r\n    Provider.prototype.getComponent = function () {\r\n        return this.component;\r\n    };\r\n    Provider.prototype.setComponent = function (component) {\r\n        var e_1, _a;\r\n        if (component.name !== this.name) {\r\n            throw Error(\"Mismatching Component \" + component.name + \" for Provider \" + this.name + \".\");\r\n        }\r\n        if (this.component) {\r\n            throw Error(\"Component for \" + this.name + \" has already been provided\");\r\n        }\r\n        this.component = component;\r\n        // if the service is eager, initialize the default instance\r\n        if (isComponentEager(component)) {\r\n            try {\r\n                this.getOrInitializeService(DEFAULT_ENTRY_NAME);\r\n            }\r\n            catch (e) {\r\n                // when the instance factory for an eager Component throws an exception during the eager\r\n                // initialization, it should not cause a fatal error.\r\n                // TODO: Investigate if we need to make it configurable, because some component may want to cause\r\n                // a fatal error in this case?\r\n            }\r\n        }\r\n        try {\r\n            // Create service instances for the pending promises and resolve them\r\n            // NOTE: if this.multipleInstances is false, only the default instance will be created\r\n            // and all promises with resolve with it regardless of the identifier.\r\n            for (var _b = tslib.__values(this.instancesDeferred.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var _d = tslib.__read(_c.value, 2), instanceIdentifier = _d[0], instanceDeferred = _d[1];\r\n                var normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\r\n                try {\r\n                    // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\r\n                    var instance = this.getOrInitializeService(normalizedIdentifier);\r\n                    instanceDeferred.resolve(instance);\r\n                }\r\n                catch (e) {\r\n                    // when the instance factory throws an exception, it should not cause\r\n                    // a fatal error. We just leave the promise unresolved.\r\n                }\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n    };\r\n    Provider.prototype.clearInstance = function (identifier) {\r\n        if (identifier === void 0) { identifier = DEFAULT_ENTRY_NAME; }\r\n        this.instancesDeferred.delete(identifier);\r\n        this.instances.delete(identifier);\r\n    };\r\n    // app.delete() will call this method on every provider to delete the services\r\n    // TODO: should we mark the provider as deleted?\r\n    Provider.prototype.delete = function () {\r\n        return tslib.__awaiter(this, void 0, void 0, function () {\r\n            var services;\r\n            return tslib.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        services = Array.from(this.instances.values());\r\n                        return [4 /*yield*/, Promise.all(tslib.__spread(services\r\n                                .filter(function (service) { return 'INTERNAL' in service; }) // legacy services\r\n                                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                                .map(function (service) { return service.INTERNAL.delete(); }), services\r\n                                .filter(function (service) { return '_delete' in service; }) // modularized services\r\n                                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                                .map(function (service) { return service._delete(); })))];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Provider.prototype.isComponentSet = function () {\r\n        return this.component != null;\r\n    };\r\n    Provider.prototype.getOrInitializeService = function (identifier) {\r\n        var instance = this.instances.get(identifier);\r\n        if (!instance && this.component) {\r\n            instance = this.component.instanceFactory(this.container, normalizeIdentifierForFactory(identifier));\r\n            this.instances.set(identifier, instance);\r\n        }\r\n        return instance || null;\r\n    };\r\n    Provider.prototype.normalizeInstanceIdentifier = function (identifier) {\r\n        if (this.component) {\r\n            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\r\n        }\r\n        else {\r\n            return identifier; // assume multiple instances are supported before the component is provided.\r\n        }\r\n    };\r\n    return Provider;\r\n}());\r\n// undefined should be passed to the service factory for the default instance\r\nfunction normalizeIdentifierForFactory(identifier) {\r\n    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\r\n}\r\nfunction isComponentEager(component) {\r\n    return component.instantiationMode === \"EAGER\" /* EAGER */;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\r\n */\r\nvar ComponentContainer = /** @class */ (function () {\r\n    function ComponentContainer(name) {\r\n        this.name = name;\r\n        this.providers = new Map();\r\n    }\r\n    /**\r\n     *\r\n     * @param component Component being added\r\n     * @param overwrite When a component with the same name has already been registered,\r\n     * if overwrite is true: overwrite the existing component with the new component and create a new\r\n     * provider with the new component. It can be useful in tests where you want to use different mocks\r\n     * for different tests.\r\n     * if overwrite is false: throw an exception\r\n     */\r\n    ComponentContainer.prototype.addComponent = function (component) {\r\n        var provider = this.getProvider(component.name);\r\n        if (provider.isComponentSet()) {\r\n            throw new Error(\"Component \" + component.name + \" has already been registered with \" + this.name);\r\n        }\r\n        provider.setComponent(component);\r\n    };\r\n    ComponentContainer.prototype.addOrOverwriteComponent = function (component) {\r\n        var provider = this.getProvider(component.name);\r\n        if (provider.isComponentSet()) {\r\n            // delete the existing provider from the container, so we can register the new component\r\n            this.providers.delete(component.name);\r\n        }\r\n        this.addComponent(component);\r\n    };\r\n    /**\r\n     * getProvider provides a type safe interface where it can only be called with a field name\r\n     * present in NameServiceMapping interface.\r\n     *\r\n     * Firebase SDKs providing services should extend NameServiceMapping interface to register\r\n     * themselves.\r\n     */\r\n    ComponentContainer.prototype.getProvider = function (name) {\r\n        if (this.providers.has(name)) {\r\n            return this.providers.get(name);\r\n        }\r\n        // create a Provider for a service that hasn't registered with Firebase\r\n        var provider = new Provider(name, this);\r\n        this.providers.set(name, provider);\r\n        return provider;\r\n    };\r\n    ComponentContainer.prototype.getProviders = function () {\r\n        return Array.from(this.providers.values());\r\n    };\r\n    return ComponentContainer;\r\n}());\n\nexports.Component = Component;\nexports.ComponentContainer = ComponentContainer;\nexports.Provider = Provider;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}